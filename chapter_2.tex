\chapter{Dynamisch programmeren}
Dynamisch programmeren is in essentie ver doorgedreven recursie, waarbij een probleem wordt opgesplitst in kleinere deelproblemen.
Deze problemen kunnen dan onafhankelijk opgelost worden.

\section{Knapzakprobleem}
Een voorbeeld is het knapzakprobleem, waarvan het algoritme bescheven staat in algoritme~\ref{algo:Knapzak}.

Wat dit algoritme in essentie doet is eerst het probleem oplossen voor 1 item, daarna voor 2 etc. 
Per iteratie van item $j$ wordt bekeken of het positief is om dit item $j$ toe te voegen aan de gekende beste oplossing voor grootte $i - size[j]$.

Hierin zijn dus de elementen van dynamisch programmeren te herkennen: het probleem wordt gereduceerd tot een belachelijk simpel probleem met \"e\"en item en kleine knapzak.
Deze eenvoudige oplossing wordt dan gebruikt om de moeilijke problemen op te lossen, waarbij het dus belangrijk is om in te zien dat er wordt verder gebouwd op deze oplossing.

%%%%%%%%%%%%%%%%%%
% Indien dit gekopieerd wordt, zie: https://en.wikibooks.org/wiki/LaTeX/Algorithms
%%%%%%%%%%%%%%%%%%
\begin{algorithm}
    \caption{Pseudocode van een oplossing voor het knapzakprobleem.}
    \label{algo:Knapzak}
    \begin{algorithmic}
        \Require{$cost[M]$}
        \Require{$size[N]$}
        \Require{$val[N]$}
        \ForAll{$j$ in $1$ to $N$ inclusive} \Comment{Iterate objects}
            \ForAll{$i$ in $1$ to $M$ inclusive} \Comment{Iterate volumes}
                \If{$i \geq size[j]$}
                    \If{$cost[i] \leq cost[i - size[j]] + val[j]$}
                        \State{$cost[i] \gets cost[i - size[j]] + val[j]$}
                        \State{$best[i] \gets = j$}
                    \EndIf
                \EndIf
            \EndFor    
        \EndFor
    \end{algorithmic}
\end{algorithm}

\section{Matrix chain product}
Een tweede voorbeeld is het \emph{matrix chain product}, waarbij gewerkt wordt met een \emph{bottum-up approach}. 
Algoritme~\ref{algo:Matrix} wordt beschouwd aan de hand van de matrices in formule~\ref{eq:matrix}.

\begin{equation}
    M_1 \cdot M_2 \cdot M_3 \cdot \dots \cdot M_N
    \label{eq:matrix}
\end{equation}



%%%%%%%%%%%%%%%%%%
% Indien dit gekopieerd wordt, zie: https://en.wikibooks.org/wiki/LaTeX/Algorithms
%%%%%%%%%%%%%%%%%%
\begin{algorithm}
    \caption{Pseudocode van een oplossing voor het knapzakprobleem.}
    \label{algo:Matrix}
    \begin{algorithmic}
        \Require{$r[N + 1]$: A list with all dimensions of the matrices}
        \State{$cost[N][N] \gets$ upper triangular matrix with 0 on diagnal}
        \ForAll{$j$ in $1$ to $N$ inclusive} \Comment{Iterate length}
            \ForAll{$i$ in $1$ to $N - j$ inclusive} \Comment{Iterate starting position}
                \ForAll{$k$ in $i + 1$ to $i + j$ inclusive} \Comment{Iterate split position}
                    \State{$t \gets cost[i][k-1][cost[k][i+j] 
                        + r[i] \cdot r[k] \cdot r[i+j+1]$}
                \EndFor
            \EndFor    
        \EndFor
    \end{algorithmic}
\end{algorithm}
